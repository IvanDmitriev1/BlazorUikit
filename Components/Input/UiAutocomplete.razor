@namespace BlazorUiKit.Components
@typeparam T where T : IEquatable<T>
@inherits UiKitInputBase<T>
@implements IExplicitHideComponent

@inject IJSRuntime JsRuntime

<InputField Disabled="@Disabled"
            Label="@Label"
            AdornmentPlacement="@AdornmentPlacement"
            Class="@ComponentCss"
            For="ValueExpression"
            IsInvalid="IsInvalid">
    <AdornmentRenderFragment>
        <InputAdornment Icon="@AdornmentIcon"
                        Size="@AdornmentSize"
                        Class="@Zindex.ToTailwindCss()"
                        AdornmentPlacement="@AdornmentPlacement"
                        AdornmentClick="() => SearchAsync(_currentText)" />
    </AdornmentRenderFragment>
    
    <InputRenderFragment>
        <UiTextInput @attributes="@AdditionalAttributes"
                     @ref="_input"
                     Class="@Zindex.ToTailwindCss()"
                     NameAttributeValue="@NameAttributeValue"
                     DebounceInterval="DebounceInterval"
                     Immediate="Immediate"
                     InputType="InputType.Text"
                     ReadOnly="ReadOnly"
                     Disabled="Disabled"
                     Placeholder="@Placeholder"

                     Text="@_currentText"
                     TextChanged="OnTextChanged" />
    </InputRenderFragment>
    
    <ChildContent>
        <PopOver @bind-Open="IsOpen"
                 ContentZIndex="Zindex"
                 OverlayZIndex="Zindex - 1"
                 Class="top-12 mt-2.5">
            <CascadingValue TValue="IExplicitHideComponent" IsFixed="true" Value="this">
                <div class="@ThemeManager.ThemeProvider.ToBackgroundCss(Color.Primary)">
                    @if (_isLoading && ProgressIndicatorInPopoverTemplate is not null)
                    {
                        @ProgressIndicatorInPopoverTemplate
                    }
                    else if (_items.Count > 0)
                    {
                        <UiList T="T"
                                @bind-SelectedValue="CurrentValue">

                            @if (BeforeItemsTemplate is not null)
                            {
                                @BeforeItemsTemplate
                            }

                            @foreach (var item in _items)
                            {
                                if (ItemWithContainerTemplate is not null)
                                {
                                    @ItemWithContainerTemplate(item)
                                }
                                else
                                {
                                    <UiListItem @key="item" T="T" Value="item">
                                        @if (ItemTemplate is not null)
                                        {
                                            @ItemTemplate(item)
                                        }
                                        else
                                        {
                                            @item.ConvertToString()
                                        }
                                    </UiListItem>
                                }
                            }
                            
                            @if (_itemsReturnedCount > MaxItems && MoreItemsTemplate is not null)
                            {
                                @MoreItemsTemplate
                            }
                            @if (AfterItemsTemplate is not null)
                            {
                                @AfterItemsTemplate
                            }
                        </UiList>
                    }
                    else if (_items.Count == 0 && NoItemsTemplate is not null)
                    {
                        @NoItemsTemplate
                    }
                </div>
            </CascadingValue>
        </PopOver>
    </ChildContent>
</InputField>

@code {

    #region Adornment

    [Parameter]
    public AdornmentPlacement AdornmentPlacement { get; set; } = Enums.AdornmentPlacement.End;

    [Parameter]
    public TablerIcon AdornmentIcon { get; set; } = TablerIcon.Search;

    [Parameter]
    public Size AdornmentSize { get; set; } = Size.Medium;

    #endregion

    #region RenderFragments

    [Parameter]
    public RenderFragment<T>? ItemWithContainerTemplate { get; set; }

    [Parameter]
    public RenderFragment<T>? ItemTemplate { get; set; }

    [Parameter]
    public RenderFragment? NoItemsTemplate { get; set; }

    [Parameter]
    public RenderFragment? MoreItemsTemplate { get; set; }

    [Parameter]
    public RenderFragment? BeforeItemsTemplate { get; set; }

    [Parameter]
    public RenderFragment? AfterItemsTemplate { get; set; }

    [Parameter]
    public RenderFragment? ProgressIndicatorInPopoverTemplate { get; set; }

    #endregion

    [Parameter]
    public int MaxItems { get; set; } = 10;

    [Parameter]
    public bool Immediate { get; set; }

    [Parameter]
    public TimeSpan DebounceInterval { get; set; }


    [Parameter]
    public required Func<string, CancellationToken, Task<IReadOnlyList<T>>> SearchFunc { get; set; }

    [Parameter]
    public required Func<T?, string?> ToStringFunc { get; set; }


    protected bool IsOpen
    {
        get => _isOpen;
        set
        {
            if (_isOpen == value)
                return;

            _isOpen = value;
            AllowRender();
        }
    }

    protected string ComponentCss => _componentCss ??= CreateComponentCss();

    private const ZIndex Zindex = ZIndex.Two;

    private UiTextInput? _input;
    private DotNetObjectReference<UiAutocomplete<T>>? _objRef;
    private CancellationTokenSource _cts = new();
    private List<T> _items = new();
    private bool _isOpen;
    private int _itemsReturnedCount;
    private bool _isLoading;
    private string _previousText = string.Empty;
    private string _currentText = string.Empty;
    private T? _previousValue = default;
    private string? _componentCss;

    private string CreateComponentCss()
    {
        using var cssBuilder = new CssBuilder(stackalloc char[128]);

        cssBuilder.AddClass(Class);

        cssBuilder.AddClass("border-4");
        cssBuilder.AddClass(ThemeManager.ThemeProvider.ToBorderCss(Color.Primary));

        return cssBuilder.ToString();
    }

    protected override void Dispose(bool disposing)
    {
        _objRef?.Dispose();
        _cts.Dispose();
    }

    protected override void OnParametersSet()
    {
        CheckIfValueChanged();
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return Task.CompletedTask;
        }

        return JsRuntime.InvokeVoidAsync("RegisterEnterKeyEvent", _input!.ElementReference, _objRef).AsTask();
    }

    protected override bool TryParseValueFromString(string? value, out T result, out string? validationErrorMessage) => throw new NotSupportedException();

    protected override string? FormatValueAsString(T? value)
    {
        if (value is null)
        {
            return null;
        }

        if (value is string valueStr)
        {
            return valueStr;
        }

        return ToStringFunc(value);
    }

    public void ExplicitHide()
    {
        IsOpen = false;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task OnEnterKey(string newText)
    {
        await SearchAsync(newText);
    }

    private Task OnTextChanged(string? arg)
    {
        if (arg is null)
            return Task.CompletedTask;

        _currentText = arg;
        return SearchAsync(_currentText);
    }

    private void CheckIfValueChanged()
    {
        if (string.IsNullOrEmpty(CurrentValueAsString) || _previousValue?.Equals(Value) == true)
        {
            return;
        }

        _previousValue = Value;
        _currentText = CurrentValueAsString;

        IsOpen = false;
    }

    private async Task SearchAsync(string? arg)
    {
        arg = arg?.Trim();

        if (string.IsNullOrWhiteSpace(arg))
            return;

        if (_previousText == arg)
        {
            IsOpen = true;
            return;
        }

        IsOpen = true;
        _items.Clear();
        _previousText = arg;
        _isLoading = true;
        AllowRender();
        StateHasChanged();

        try
        {
            await CancelTokenAsync();

            var searchItems = await SearchFunc.Invoke(arg, _cts.Token);
            int itemsLength = searchItems.Count <= MaxItems ? searchItems.Count : MaxItems;

            if (itemsLength > _items.Capacity)
                _items.Capacity = itemsLength;

            _itemsReturnedCount = searchItems.Count;

            for (int i = 0; i < itemsLength; i++)
            {
                _items.Add(searchItems[i]);
            }
        }
        catch (TaskCanceledException)
        {
            return;
        }
        catch (OperationCanceledException)
        {
            return;
        }
        catch (Exception ex)
        {
            await DispatchExceptionAsync(ex);
            return;
        }

        _isLoading = false;
        AllowRender();
        StateHasChanged();
    }

    private async ValueTask CancelTokenAsync()
    {
        try
        {
            await _cts.CancelAsync();
        }
        catch (TaskCanceledException)
        {
            
        }
        catch (OperationCanceledException)
        {

        }
        finally
        {
            _cts.Dispose();
            _cts = new CancellationTokenSource();
        }
    }
}